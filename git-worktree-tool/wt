#!/bin/bash

# wt - Simplified Git Worktree Management
# Provides an intuitive interface for creating, listing, switching, and deleting git worktrees

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ============================================================================
# Helper Functions
# ============================================================================

# Print error and exit
error() {
  echo -e "${RED}❌ Error:${NC} $1" >&2
  exit 1
}

# Print success message
success() {
  echo -e "${GREEN}✓${NC} $1"
}

# Print info message
info() {
  echo -e "${BLUE}ℹ${NC} $1"
}

# Print warning message
warn() {
  echo -e "${YELLOW}⚠${NC} $1"
}

# Detect if we're in a git repository
check_git_repo() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    error "Not a git repository. Please run this from within a git repository."
  fi
}

# Get the git repository root
get_repo_root() {
  git rev-parse --show-toplevel
}

# Get the repository name
get_repo_name() {
  basename "$(get_repo_root)"
}

# Get the default branch (main or master)
get_default_branch() {
  # Try to get from remote HEAD first
  if git symbolic-ref refs/remotes/origin/HEAD > /dev/null 2>&1; then
    git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'
  else
    # Fallback to checking local branches
    if git rev-parse --verify main > /dev/null 2>&1; then
      echo "main"
    elif git rev-parse --verify master > /dev/null 2>&1; then
      echo "master"
    else
      error "Could not determine default branch. Please ensure 'main' or 'master' exists."
    fi
  fi
}

# Detect the package manager
get_package_manager() {
  local repo_root=$(get_repo_root)

  if [ -f "$repo_root/bun.lockb" ]; then
    echo "bun"
  elif [ -f "$repo_root/package-lock.json" ]; then
    echo "npm"
  elif [ -f "$repo_root/yarn.lock" ]; then
    echo "yarn"
  elif [ -f "$repo_root/pnpm-lock.yaml" ]; then
    echo "pnpm"
  else
    # Default to npm if no lock file found
    echo "npm"
  fi
}

# Check if a worktree exists
worktree_exists() {
  local worktree_path="$1"
  git worktree list | grep -q "^$worktree_path" && return 0 || return 1
}

# Find worktree by branch name (fuzzy match)
find_worktree_by_branch() {
  local branch_name="$1"
  local match=$(git worktree list --porcelain | grep " $branch_name$" | awk '{print $1}' | head -1)

  if [ -z "$match" ]; then
    # Try fuzzy matching if exact match fails
    match=$(git worktree list | grep -i "$branch_name" | awk '{print $1}' | head -1)
  fi

  echo "$match"
}

# Get the current worktree path
get_current_worktree() {
  git rev-parse --show-toplevel
}

# ============================================================================
# Command: list
# ============================================================================

cmd_list() {
  check_git_repo

  local current_worktree=$(get_current_worktree)

  echo -e "\n${BLUE}Current worktrees:${NC}"

  # Parse porcelain output: it has 3 lines per worktree (worktree, HEAD, branch)
  local worktree_path=""
  local branch=""

  git worktree list --porcelain | while read -r line; do
    if [[ "$line" =~ ^worktree ]]; then
      # New worktree entry
      worktree_path=$(echo "$line" | sed 's/^worktree //')
      branch=""
    elif [[ "$line" =~ ^branch ]]; then
      # Extract branch name from refs/heads/branch-name
      branch=$(echo "$line" | sed 's/^branch refs\/heads\///')

      # Now display the worktree
      local worktree_name=$(basename "$worktree_path")

      if [ "$worktree_path" = "$current_worktree" ]; then
        printf "  ${GREEN}✓${NC} %-30s ${BLUE}[${branch}]${NC}\n" "$worktree_name"
      else
        printf "  ${YELLOW}•${NC} %-30s ${BLUE}[${branch}]${NC}\n" "$worktree_name"
      fi
    fi
  done

  echo ""
}

# ============================================================================
# Command: create
# ============================================================================

cmd_create() {
  check_git_repo

  local branch_name="$1"
  local open_code=false
  local go_flag=false

  # Check for flags
  if [ "${2:-}" = "--code" ]; then
    open_code=true
  elif [ "${2:-}" = "--go" ]; then
    go_flag=true
  fi

  if [ -z "$branch_name" ]; then
    error "Branch name required. Usage: wt create <branch-name> [--code|--go]"
  fi

  local repo_root=$(get_repo_root)
  local repo_name=$(get_repo_name)
  local worktree_path="../${repo_name}-${branch_name}"
  local worktree_full_path="${repo_root}/../${repo_name}-${branch_name}"
  local default_branch=$(get_default_branch)
  local pkg_manager=$(get_package_manager)

  # Check if worktree already exists
  if [ -d "$worktree_full_path" ]; then
    error "Worktree already exists at $worktree_path"
  fi

  # Check if branch already exists
  if git rev-parse --verify "$branch_name" > /dev/null 2>&1; then
    warn "Branch '$branch_name' already exists locally"
    read -p "Continue with existing branch? (y/n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      error "Cancelled"
    fi
    # Create worktree from existing branch
    info "Creating worktree for existing branch..."
    git worktree add "$worktree_full_path" "$branch_name" || error "Failed to create worktree"
  else
    # Create new branch
    info "Creating worktree with new branch..."
    git worktree add -b "$branch_name" "$worktree_full_path" "origin/$default_branch" || error "Failed to create worktree"
  fi

  success "Worktree created at $worktree_path"

  # Install dependencies
  info "Installing dependencies in $worktree_path..."
  (
    cd "$worktree_full_path"
    case "$pkg_manager" in
      bun)
        bun install || warn "bun install failed"
        ;;
      npm)
        npm install || warn "npm install failed"
        ;;
      yarn)
        yarn install || warn "yarn install failed"
        ;;
      pnpm)
        pnpm install || warn "pnpm install failed"
        ;;
    esac
  )

  success "Dependencies installed"

  # Open VS Code if requested
  if [ "$open_code" = true ]; then
    info "Opening VS Code..."
    code "$worktree_full_path" &
  fi

  # Handle --go flag: switch to worktree and launch Claude Code
  if [ "$go_flag" = true ]; then
    info "Switching to worktree and launching Claude Code..."
    cd "$worktree_full_path"
    code . &
    success "Opened in: $worktree_full_path"
    echo ""
    return 0
  fi

  info "To switch to this worktree, run: ${BLUE}wt switch $branch_name${NC}"
  echo ""
}

# ============================================================================
# Command: switch
# ============================================================================

cmd_switch() {
  check_git_repo

  local branch_name="$1"

  if [ -z "$branch_name" ]; then
    error "Branch name required. Usage: wt switch <branch-name>"
  fi

  local worktree_path=$(find_worktree_by_branch "$branch_name")

  if [ -z "$worktree_path" ]; then
    error "Worktree not found for branch matching '$branch_name'"
  fi

  # Output cd command for shell function to eval
  echo "cd '$worktree_path'"
}

# ============================================================================
# Command: delete
# ============================================================================

cmd_delete() {
  check_git_repo

  local branch_name="$1"
  local keep_branch=false

  # Check for --keep-branch flag
  if [ "${2:-}" = "--keep-branch" ]; then
    keep_branch=true
  fi

  if [ -z "$branch_name" ]; then
    error "Branch name required. Usage: wt delete <branch-name> [--keep-branch]"
  fi

  local worktree_path=$(find_worktree_by_branch "$branch_name")

  if [ -z "$worktree_path" ]; then
    error "Worktree not found for branch matching '$branch_name'"
  fi

  local current_worktree=$(get_current_worktree)

  # If trying to delete current worktree, switch to main first
  if [ "$worktree_path" = "$current_worktree" ]; then
    warn "Cannot delete current worktree. Switching to main repository..."
    local repo_root=$(get_repo_root)
    cd "$repo_root"
    info "Switched to main repository. Now deleting worktree..."
  fi

  # Check for uncommitted changes
  if [ -d "$worktree_path/.git" ]; then
    local has_changes=$(cd "$worktree_path" && git status --porcelain | wc -l)
    if [ "$has_changes" -gt 0 ]; then
      warn "Worktree has uncommitted changes"
      echo "Options:"
      echo "  (c) Commit the changes"
      echo "  (s) Stash the changes"
      echo "  (f) Force delete (will lose changes)"
      echo "  (q) Cancel"
      read -p "What would you like to do? [c/s/f/q] " -n 1 -r
      echo

      case $REPLY in
        c)
          (cd "$worktree_path" && git add -A && git commit -m "WIP: work in progress before deleting worktree")
          ;;
        s)
          (cd "$worktree_path" && git stash)
          ;;
        f)
          warn "Force deleting with uncommitted changes"
          ;;
        *)
          error "Cancelled"
          ;;
      esac
    fi
  fi

  # Remove worktree
  git worktree remove "$worktree_path" || error "Failed to remove worktree"
  success "Worktree deleted at $worktree_path"

  # Delete branch by default (unless --keep-branch)
  if [ "$keep_branch" = false ]; then
    read -p "Delete branch '$branch_name' as well? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      git branch -D "$branch_name" 2>/dev/null || true
      git push origin --delete "$branch_name" 2>/dev/null || true
      success "Branch deleted"
    fi
  fi

  # Clean up stale worktree references
  git worktree prune

  echo ""
}

# ============================================================================
# Command: help
# ============================================================================

cmd_help() {
  cat << 'EOF'
wt - Simplified Git Worktree Management

USAGE:
  wt <command> [options]

COMMANDS:
  list                    List all active worktrees
  create <branch>         Create a new worktree with <branch>
                         Options: --code (opens in VS Code)
                                  --go (cd into worktree + launch Claude Code)
  switch <branch>         Switch to a worktree (via shell function)
  delete <branch>         Delete a worktree (deletes branch by default)
                         Options: --keep-branch (preserve the git branch)
  help                    Show this help message

EXAMPLES:
  wt list
  wt create DEV-123
  wt create DEV-123 --code
  wt create DEV-123 --go
  wt switch DEV-123
  wt delete DEV-123
  wt delete DEV-123 --keep-branch

SHELL SETUP (required for 'switch' to work):
  Add this function to your ~/.zshrc:

    wt() {
      local script="$HOME/.claude/skills/git-worktree-guide/wt"
      if [ "$1" = "switch" ] || ([ $# -eq 1 ] && [ "$1" != "list" ] && [ "$1" != "create" ] && [ "$1" != "delete" ] && [ "$1" != "help" ]); then
        local output=$("$script" "$@")
        if [ $? -eq 0 ]; then
          eval "$output"
        else
          echo "$output"
        fi
      else
        "$script" "$@"
      fi
    }

EOF
}

# ============================================================================
# Main
# ============================================================================

main() {
  local command="${1:-help}"

  case "$command" in
    list)
      cmd_list
      ;;
    create)
      cmd_create "${2:-}" "${3:-}"
      ;;
    switch)
      cmd_switch "${2:-}"
      ;;
    delete)
      cmd_delete "${2:-}" "${3:-}"
      ;;
    help|--help|-h)
      cmd_help
      ;;
    *)
      error "Unknown command: $command. Run 'wt help' for usage."
      ;;
  esac
}

# Run main with all arguments
main "$@"
