#!/bin/bash

# wt - Simplified Git Worktree Management
# Provides an intuitive interface for creating, listing, switching, and deleting git worktrees

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Version (replaced during release process)
VERSION="2.1.0"

# ============================================================================
# Configuration System
# ============================================================================

# Config file location (follows XDG Base Directory spec)
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/wt"
CONFIG_FILE="$CONFIG_DIR/config"

# Default configuration values
DEFAULT_EDITOR="code"
DEFAULT_EDITOR_FLAGS=""
DEFAULT_AUTO_INSTALL="true"
DEFAULT_DELETE_BRANCH_PROMPT="true"
DEFAULT_PACKAGE_MANAGER=""  # Empty = auto-detect
DEFAULT_WORKTREE_NAME_PATTERN="{repo}-{branch}"

# Current configuration (will be loaded from file or defaults)
EDITOR="$DEFAULT_EDITOR"
EDITOR_FLAGS="$DEFAULT_EDITOR_FLAGS"
AUTO_INSTALL="$DEFAULT_AUTO_INSTALL"
DELETE_BRANCH_PROMPT="$DEFAULT_DELETE_BRANCH_PROMPT"
PACKAGE_MANAGER="$DEFAULT_PACKAGE_MANAGER"
WORKTREE_NAME_PATTERN="$DEFAULT_WORKTREE_NAME_PATTERN"

# Load configuration from file if it exists
load_config() {
  if [ -f "$CONFIG_FILE" ]; then
    # Source the config file, but validate it first
    if [ -r "$CONFIG_FILE" ]; then
      # shellcheck source=/dev/null
      # Use a subshell to avoid polluting the environment with unexpected variables
      source "$CONFIG_FILE" 2>/dev/null || true
    fi
  fi
}

# Create default configuration file if it doesn't exist
init_config() {
  if [ ! -f "$CONFIG_FILE" ]; then
    mkdir -p "$CONFIG_DIR"

    cat > "$CONFIG_FILE" << 'EOFCONFIG'
# wt Configuration File
# Location: ~/.config/wt/config
#
# This file allows you to customize the behavior of the wt worktree tool.
# All values below are optional - if not specified, defaults will be used.

# The editor to open when using --code or --go flags
# Examples: code, cursor, zed, nvim, vim
EDITOR="code"

# Additional flags to pass to the editor
# Examples: "" (none), "--remote=wsl", "--wait"
EDITOR_FLAGS=""

# Automatically install dependencies after creating a worktree
# Values: true or false
AUTO_INSTALL="true"

# Prompt before deleting branch when using 'wt delete'
# If false, branch will be deleted without prompt
# Values: true or false
DELETE_BRANCH_PROMPT="true"

# Override package manager detection (bun, npm, yarn, pnpm)
# Leave empty to auto-detect based on lock files
PACKAGE_MANAGER=""

# Customize worktree naming pattern
# Available variables: {repo} (repository name), {branch} (branch name)
# Default: "{repo}-{branch}"
# Examples: "{branch}", "wt-{branch}", "{repo}/{branch}"
WORKTREE_NAME_PATTERN="{repo}-{branch}"
EOFCONFIG

    info "Created config file at $CONFIG_FILE"
  fi
}

# Parse the worktree name pattern with variables
apply_worktree_pattern() {
  local pattern="$1"
  local repo_name="$2"
  local branch_name="$3"

  # Replace {repo} and {branch} placeholders
  pattern="${pattern//\{repo\}/$repo_name}"
  pattern="${pattern//\{branch\}/$branch_name}"

  echo "$pattern"
}

# ============================================================================
# Helper Functions
# ============================================================================

# Print error and exit
error() {
  echo -e "${RED}❌ Error:${NC} $1" >&2
  exit 1
}

# Print success message
success() {
  echo -e "${GREEN}✓${NC} $1"
}

# Print info message
info() {
  echo -e "${BLUE}ℹ${NC} $1"
}

# Print warning message
warn() {
  echo -e "${YELLOW}⚠${NC} $1"
}

# Detect if we're in a git repository
check_git_repo() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    error "Not a git repository. Please run this from within a git repository."
  fi
}

# Get the git repository root
get_repo_root() {
  git rev-parse --show-toplevel
}

# Get the repository name
get_repo_name() {
  basename "$(get_repo_root)"
}

# Get the default branch (main or master)
get_default_branch() {
  # Try to get from remote HEAD first
  if git symbolic-ref refs/remotes/origin/HEAD > /dev/null 2>&1; then
    git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'
  else
    # Fallback to checking local branches
    if git rev-parse --verify main > /dev/null 2>&1; then
      echo "main"
    elif git rev-parse --verify master > /dev/null 2>&1; then
      echo "master"
    else
      error "Could not determine default branch. Please ensure 'main' or 'master' exists."
    fi
  fi
}

# Detect the package manager
get_package_manager() {
  local repo_root=$(get_repo_root)

  if [ -f "$repo_root/bun.lockb" ]; then
    echo "bun"
  elif [ -f "$repo_root/package-lock.json" ]; then
    echo "npm"
  elif [ -f "$repo_root/yarn.lock" ]; then
    echo "yarn"
  elif [ -f "$repo_root/pnpm-lock.yaml" ]; then
    echo "pnpm"
  else
    # Default to npm if no lock file found
    echo "npm"
  fi
}

# Check if a worktree exists
worktree_exists() {
  local worktree_path="$1"
  git worktree list | grep -q "^$worktree_path" && return 0 || return 1
}

# Find worktree by branch name (fuzzy match)
find_worktree_by_branch() {
  local branch_name="$1"
  local match=$(git worktree list --porcelain | grep " $branch_name$" | awk '{print $1}' | head -1)

  if [ -z "$match" ]; then
    # Try fuzzy matching if exact match fails
    match=$(git worktree list | grep -i "$branch_name" | awk '{print $1}' | head -1)
  fi

  echo "$match"
}

# Get the current worktree path
get_current_worktree() {
  git rev-parse --show-toplevel
}

# ============================================================================
# Command: list
# ============================================================================

cmd_list() {
  check_git_repo

  local current_worktree=$(get_current_worktree)

  echo -e "\n${BLUE}Current worktrees:${NC}"

  # Parse porcelain output: it has 3 lines per worktree (worktree, HEAD, branch)
  local worktree_path=""
  local branch=""

  git worktree list --porcelain | while read -r line; do
    if [[ "$line" =~ ^worktree ]]; then
      # New worktree entry
      worktree_path=$(echo "$line" | sed 's/^worktree //')
      branch=""
    elif [[ "$line" =~ ^branch ]]; then
      # Extract branch name from refs/heads/branch-name
      branch=$(echo "$line" | sed 's/^branch refs\/heads\///')

      # Now display the worktree
      local worktree_name=$(basename "$worktree_path")

      if [ "$worktree_path" = "$current_worktree" ]; then
        printf "  ${GREEN}✓${NC} %-30s ${BLUE}[${branch}]${NC}\n" "$worktree_name"
      else
        printf "  ${YELLOW}•${NC} %-30s ${BLUE}[${branch}]${NC}\n" "$worktree_name"
      fi
    fi
  done

  echo ""
}

# ============================================================================
# Command: create
# ============================================================================

cmd_create() {
  check_git_repo

  local branch_name="$1"
  local open_code=false
  local go_flag=false

  # Check for flags
  if [ "${2:-}" = "--code" ]; then
    open_code=true
  elif [ "${2:-}" = "--go" ]; then
    go_flag=true
  fi

  if [ -z "$branch_name" ]; then
    error "Branch name required. Usage: wt create <branch-name> [--code|--go]"
  fi

  local repo_root=$(get_repo_root)
  local repo_name=$(get_repo_name)

  # Apply the worktree naming pattern from config
  local worktree_name=$(apply_worktree_pattern "$WORKTREE_NAME_PATTERN" "$repo_name" "$branch_name")
  local worktree_path="../${worktree_name}"
  local worktree_full_path="${repo_root}/../${worktree_name}"

  local default_branch=$(get_default_branch)
  # Use configured package manager or auto-detect
  local pkg_manager="${PACKAGE_MANAGER}"
  if [ -z "$pkg_manager" ]; then
    pkg_manager=$(get_package_manager)
  fi

  # Check if worktree already exists
  if [ -d "$worktree_full_path" ]; then
    error "Worktree already exists at $worktree_path"
  fi

  # Check if branch already exists
  if git rev-parse --verify "$branch_name" > /dev/null 2>&1; then
    warn "Branch '$branch_name' already exists locally"
    read -p "Continue with existing branch? (y/n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      error "Cancelled"
    fi
    # Create worktree from existing branch
    info "Creating worktree for existing branch..."
    git worktree add "$worktree_full_path" "$branch_name" || error "Failed to create worktree"
  else
    # Create new branch
    info "Creating worktree with new branch..."
    git worktree add -b "$branch_name" "$worktree_full_path" "origin/$default_branch" || error "Failed to create worktree"
  fi

  success "Worktree created at $worktree_path"

  # Install dependencies if AUTO_INSTALL is enabled
  if [ "$AUTO_INSTALL" = "true" ]; then
    info "Installing dependencies in $worktree_path..."
    (
      cd "$worktree_full_path"
      case "$pkg_manager" in
        bun)
          bun install || warn "bun install failed"
          ;;
        npm)
          npm install || warn "npm install failed"
          ;;
        yarn)
          yarn install || warn "yarn install failed"
          ;;
        pnpm)
          pnpm install || warn "pnpm install failed"
          ;;
      esac
    )
    success "Dependencies installed"
  else
    info "Skipping dependency installation (AUTO_INSTALL=false)"
  fi

  # Open editor if requested (via --code or --go flags)
  if [ "$open_code" = true ]; then
    info "Opening editor: $EDITOR"
    # shellcheck disable=SC2086
    $EDITOR $EDITOR_FLAGS "$worktree_full_path" &
  fi

  # Handle --go flag: switch to worktree and launch editor
  if [ "$go_flag" = true ]; then
    info "Switching to worktree and launching editor: $EDITOR"
    cd "$worktree_full_path"
    # shellcheck disable=SC2086
    $EDITOR $EDITOR_FLAGS . &
    success "Opened in: $worktree_full_path"
    echo ""
    return 0
  fi

  info "To switch to this worktree, run: ${BLUE}wt switch $branch_name${NC}"
  echo ""
}

# ============================================================================
# Command: switch
# ============================================================================

cmd_switch() {
  check_git_repo

  local branch_name="$1"

  if [ -z "$branch_name" ]; then
    error "Branch name required. Usage: wt switch <branch-name>"
  fi

  local worktree_path=$(find_worktree_by_branch "$branch_name")

  if [ -z "$worktree_path" ]; then
    error "Worktree not found for branch matching '$branch_name'"
  fi

  # Output cd command for shell function to eval
  echo "cd '$worktree_path'"
}

# ============================================================================
# Command: delete
# ============================================================================

cmd_delete() {
  check_git_repo

  local branch_name="$1"
  local keep_branch=false

  # Check for --keep-branch flag
  if [ "${2:-}" = "--keep-branch" ]; then
    keep_branch=true
  fi

  if [ -z "$branch_name" ]; then
    error "Branch name required. Usage: wt delete <branch-name> [--keep-branch]"
  fi

  local worktree_path=$(find_worktree_by_branch "$branch_name")

  if [ -z "$worktree_path" ]; then
    error "Worktree not found for branch matching '$branch_name'"
  fi

  local current_worktree=$(get_current_worktree)

  # If trying to delete current worktree, switch to main first
  if [ "$worktree_path" = "$current_worktree" ]; then
    warn "Cannot delete current worktree. Switching to main repository..."
    local repo_root=$(get_repo_root)
    cd "$repo_root"
    info "Switched to main repository. Now deleting worktree..."
  fi

  # Check for uncommitted changes
  if [ -d "$worktree_path/.git" ]; then
    local has_changes=$(cd "$worktree_path" && git status --porcelain | wc -l)
    if [ "$has_changes" -gt 0 ]; then
      warn "Worktree has uncommitted changes"
      echo "Options:"
      echo "  (c) Commit the changes"
      echo "  (s) Stash the changes"
      echo "  (f) Force delete (will lose changes)"
      echo "  (q) Cancel"
      read -p "What would you like to do? [c/s/f/q] " -n 1 -r
      echo

      case $REPLY in
        c)
          (cd "$worktree_path" && git add -A && git commit -m "WIP: work in progress before deleting worktree")
          ;;
        s)
          (cd "$worktree_path" && git stash)
          ;;
        f)
          warn "Force deleting with uncommitted changes"
          ;;
        *)
          error "Cancelled"
          ;;
      esac
    fi
  fi

  # Remove worktree
  git worktree remove "$worktree_path" || error "Failed to remove worktree"
  success "Worktree deleted at $worktree_path"

  # Delete branch by default (unless --keep-branch)
  if [ "$keep_branch" = false ]; then
    local should_delete_branch=false

    if [ "$DELETE_BRANCH_PROMPT" = "true" ]; then
      # Prompt the user
      read -p "Delete branch '$branch_name' as well? (y/n) " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]]; then
        should_delete_branch=true
      fi
    else
      # Delete without prompting
      should_delete_branch=true
    fi

    if [ "$should_delete_branch" = true ]; then
      git branch -D "$branch_name" 2>/dev/null || true
      git push origin --delete "$branch_name" 2>/dev/null || true
      success "Branch deleted"
    fi
  fi

  # Clean up stale worktree references
  git worktree prune

  echo ""
}

# ============================================================================
# Command: help
# ============================================================================

cmd_help() {
  echo "wt - Simplified Git Worktree Management (v${VERSION})"
  cat << 'EOF'

USAGE:
  wt <command> [options]

COMMANDS:
  list                    List all active worktrees
  create <branch>         Create a new worktree with <branch>
                         Options: --code (opens in configured editor)
                                  --go (cd into worktree + launch editor)
  switch <branch>         Switch to a worktree (via shell function)
  delete <branch>         Delete a worktree (deletes branch by default)
                         Options: --keep-branch (preserve the git branch)
  config <subcommand>     Manage configuration
                         Subcommands: edit, show, reset, path
  help                    Show this help message

CONFIGURATION:
  Config file: ~/.config/wt/config
  Create automatically on first use.

  Available options:
    EDITOR               - Editor command (default: code)
    EDITOR_FLAGS         - Flags for editor (default: "")
    AUTO_INSTALL         - Auto-install dependencies (default: true)
    DELETE_BRANCH_PROMPT - Prompt before deleting branch (default: true)
    PACKAGE_MANAGER      - Override PM detection: bun|npm|yarn|pnpm (default: auto)
    WORKTREE_NAME_PATTERN - Pattern for worktree names (default: {repo}-{branch})

EXAMPLES:
  wt list
  wt create DEV-123
  wt create DEV-123 --code
  wt create DEV-123 --go
  wt switch DEV-123
  wt delete DEV-123
  wt delete DEV-123 --keep-branch

  wt config show            - Display current configuration
  wt config edit            - Edit config in editor
  wt config path            - Show config file location
  wt config reset           - Reset to defaults

SHELL SETUP (required for 'switch' to work):
  Add this function to your ~/.zshrc:

    wt() {
      local script="$HOME/.claude/skills/git-worktree-guide/wt"
      if [ "$1" = "switch" ] || ([ $# -eq 1 ] && [ "$1" != "list" ] && [ "$1" != "create" ] && [ "$1" != "delete" ] && [ "$1" != "config" ] && [ "$1" != "help" ]); then
        local output=$("$script" "$@")
        if [ $? -eq 0 ]; then
          eval "$output"
        else
          echo "$output"
        fi
      else
        "$script" "$@"
      fi
    }

EOF
}

# ============================================================================
# Command: config
# ============================================================================

cmd_config() {
  local subcommand="${1:-show}"

  case "$subcommand" in
    edit)
      # Open config file in editor
      if [ ! -f "$CONFIG_FILE" ]; then
        init_config
      fi

      if [ -z "$EDITOR" ] || [ "$EDITOR" = "code" ]; then
        code "$CONFIG_FILE"
      else
        "$EDITOR" "$CONFIG_FILE"
      fi
      success "Config file opened in editor"
      ;;
    show)
      # Display current configuration
      if [ ! -f "$CONFIG_FILE" ]; then
        info "No config file found. Using defaults."
        echo ""
      else
        echo -e "${BLUE}Current configuration (from $CONFIG_FILE):${NC}"
        cat "$CONFIG_FILE"
        echo ""
      fi

      echo -e "${BLUE}Active settings:${NC}"
      echo "  EDITOR: $EDITOR"
      echo "  EDITOR_FLAGS: ${EDITOR_FLAGS:-(none)}"
      echo "  AUTO_INSTALL: $AUTO_INSTALL"
      echo "  DELETE_BRANCH_PROMPT: $DELETE_BRANCH_PROMPT"
      echo "  PACKAGE_MANAGER: ${PACKAGE_MANAGER:-(auto-detect)}"
      echo "  WORKTREE_NAME_PATTERN: $WORKTREE_NAME_PATTERN"
      echo ""
      ;;
    reset)
      # Reset to defaults by removing config file
      if [ -f "$CONFIG_FILE" ]; then
        read -p "Reset configuration to defaults? This will delete $CONFIG_FILE (y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
          rm "$CONFIG_FILE"
          success "Configuration reset to defaults"
        else
          info "Reset cancelled"
        fi
      else
        info "Already using default configuration"
      fi
      echo ""
      ;;
    path)
      # Show the config file path
      echo "$CONFIG_FILE"
      ;;
    *)
      error "Unknown config subcommand: $subcommand. Use: edit, show, reset, path"
      ;;
  esac
}

# ============================================================================
# Main
# ============================================================================

main() {
  # Initialize config directory if needed (silent - only creates on first run)
  if [ ! -d "$CONFIG_DIR" ]; then
    mkdir -p "$CONFIG_DIR"
  fi

  # Load user configuration (must happen before any command)
  load_config

  local command="${1:-help}"

  case "$command" in
    list)
      cmd_list
      ;;
    create)
      cmd_create "${2:-}" "${3:-}"
      ;;
    switch)
      cmd_switch "${2:-}"
      ;;
    delete)
      cmd_delete "${2:-}" "${3:-}"
      ;;
<<<<<<< HEAD
    --version|-v|version)
      echo "wt version ${VERSION}"
      exit 0
=======
    config)
      cmd_config "${2:-show}"
>>>>>>> 888761c (feat: add configuration system for wt tool)
      ;;
    help|--help|-h)
      cmd_help
      ;;
    *)
      error "Unknown command: $command. Run 'wt help' for usage."
      ;;
  esac
}

# Run main with all arguments
main "$@"
