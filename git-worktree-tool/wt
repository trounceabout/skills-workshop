#!/bin/bash

# wt - Simplified Git Worktree Management
# Provides an intuitive interface for creating, listing, switching, and deleting git worktrees

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Version (replaced during release process)
VERSION="2.1.1"

# ============================================================================
# Configuration System
# ============================================================================

# Config file location (follows XDG Base Directory spec)
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/wt"
CONFIG_FILE="$CONFIG_DIR/config"

# Default configuration values
DEFAULT_EDITOR="code"
DEFAULT_EDITOR_FLAGS=""
DEFAULT_AUTO_INSTALL="true"
DEFAULT_DELETE_BRANCH_PROMPT="true"
DEFAULT_PACKAGE_MANAGER=""  # Empty = auto-detect
DEFAULT_WORKTREE_NAME_PATTERN="{repo}-{branch}"

# Current configuration (will be loaded from file or defaults)
EDITOR="$DEFAULT_EDITOR"
EDITOR_FLAGS="$DEFAULT_EDITOR_FLAGS"
AUTO_INSTALL="$DEFAULT_AUTO_INSTALL"
DELETE_BRANCH_PROMPT="$DEFAULT_DELETE_BRANCH_PROMPT"
PACKAGE_MANAGER="$DEFAULT_PACKAGE_MANAGER"
WORKTREE_NAME_PATTERN="$DEFAULT_WORKTREE_NAME_PATTERN"

# Load configuration from file if it exists
load_config() {
  if [ -f "$CONFIG_FILE" ]; then
    # Source the config file, but validate it first
    if [ -r "$CONFIG_FILE" ]; then
      # shellcheck source=/dev/null
      # Use a subshell to avoid polluting the environment with unexpected variables
      source "$CONFIG_FILE" 2>/dev/null || true
    fi
  fi
}

# Create default configuration file if it doesn't exist
init_config() {
  if [ ! -f "$CONFIG_FILE" ]; then
    mkdir -p "$CONFIG_DIR"

    cat > "$CONFIG_FILE" << 'EOFCONFIG'
# wt Configuration File
# Location: ~/.config/wt/config
#
# This file allows you to customize the behavior of the wt worktree tool.
# All values below are optional - if not specified, defaults will be used.

# The editor to open when using --code or --go flags
# Examples: code, cursor, zed, nvim, vim
EDITOR="code"

# Additional flags to pass to the editor
# Examples: "" (none), "--remote=wsl", "--wait"
EDITOR_FLAGS=""

# Automatically install dependencies after creating a worktree
# Values: true or false
AUTO_INSTALL="true"

# Prompt before deleting branch when using 'wt delete'
# If false, branch will be deleted without prompt
# Values: true or false
DELETE_BRANCH_PROMPT="true"

# Override package manager detection (bun, npm, yarn, pnpm)
# Leave empty to auto-detect based on lock files
PACKAGE_MANAGER=""

# Customize worktree naming pattern
# Available variables: {repo} (repository name), {branch} (branch name)
# Default: "{repo}-{branch}"
# Examples: "{branch}", "wt-{branch}", "{repo}/{branch}"
WORKTREE_NAME_PATTERN="{repo}-{branch}"
EOFCONFIG

    info "Created config file at $CONFIG_FILE"
  fi
}

# Parse the worktree name pattern with variables
apply_worktree_pattern() {
  local pattern="$1"
  local repo_name="$2"
  local branch_name="$3"

  # Replace {repo} and {branch} placeholders
  pattern="${pattern//\{repo\}/$repo_name}"
  pattern="${pattern//\{branch\}/$branch_name}"

  echo "$pattern"
}

# ============================================================================
# Helper Functions
# ============================================================================

# Print error and exit
error() {
  echo -e "${RED}❌ Error:${NC} $1" >&2
  exit 1
}

# Print success message
success() {
  echo -e "${GREEN}✓${NC} $1"
}

# Print info message
info() {
  echo -e "${BLUE}ℹ${NC} $1"
}

# Print warning message
warn() {
  echo -e "${YELLOW}⚠${NC} $1"
}

# Validate branch name for git compatibility
# Checks for empty names, spaces, and invalid git ref characters
validate_branch_name() {
  local branch="$1"

  # Check for empty
  if [[ -z "$branch" ]]; then
    error "Branch name cannot be empty"
  fi

  # Check for spaces
  if [[ "$branch" =~ [[:space:]] ]]; then
    error "Branch name cannot contain spaces: '$branch'"
  fi

  # Check for invalid git ref characters: ~ ^ : \ * ? [
  if [[ "$branch" =~ [\~\^:\\\*\?\[] ]]; then
    error "Branch name contains invalid characters: '$branch'"
  fi

  # Check for leading/trailing dots or slashes
  if [[ "$branch" =~ ^[./] ]] || [[ "$branch" =~ [./]$ ]]; then
    error "Branch name cannot start or end with '.' or '/': '$branch'"
  fi

  # Check for consecutive dots (..)
  if [[ "$branch" =~ \.\. ]]; then
    error "Branch name cannot contain '..': '$branch'"
  fi
}

# check_git_repo - Verify we're inside a git repository
# Exits with error if not in a git repo
check_git_repo() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    error "Not a git repository. Please run this from within a git repository."
  fi
}

# get_repo_root - Get the absolute path to the repository root
# Returns: Absolute path to repo root (e.g., /Users/name/repos/myproject)
get_repo_root() {
  git rev-parse --show-toplevel
}

# get_repo_name - Get the repository directory name
# Returns: Just the directory name, not the full path (e.g., "myproject")
get_repo_name() {
  basename "$(get_repo_root)"
}

# get_default_branch - Detect the repository's default branch
# Checks remote HEAD first, falls back to checking for main/master locally
# Returns: Branch name (typically "main" or "master")
# Exits with error if neither main nor master exists
get_default_branch() {
  # Try to get from remote HEAD first
  if git symbolic-ref refs/remotes/origin/HEAD > /dev/null 2>&1; then
    git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'
  else
    # Fallback to checking local branches
    if git rev-parse --verify main > /dev/null 2>&1; then
      echo "main"
    elif git rev-parse --verify master > /dev/null 2>&1; then
      echo "master"
    else
      error "Could not determine default branch. Please ensure 'main' or 'master' exists."
    fi
  fi
}

# get_package_manager - Detect which package manager the project uses
# Checks for lock files in order: bun, npm, yarn, pnpm
# Returns: Package manager name (defaults to "npm" if none detected)
get_package_manager() {
  local repo_root
  repo_root=$(get_repo_root)

  if [ -f "$repo_root/bun.lockb" ]; then
    echo "bun"
  elif [ -f "$repo_root/package-lock.json" ]; then
    echo "npm"
  elif [ -f "$repo_root/yarn.lock" ]; then
    echo "yarn"
  elif [ -f "$repo_root/pnpm-lock.yaml" ]; then
    echo "pnpm"
  else
    # Default to npm if no lock file found
    echo "npm"
  fi
}

# worktree_exists - Check if a worktree exists at the given path
# Arguments: $1 - worktree path to check
# Returns: 0 if exists, 1 if not
worktree_exists() {
  local worktree_path="$1"
  git worktree list | grep -q "^$worktree_path" && return 0 || return 1
}

# find_worktree_by_branch - Find a worktree's path by its branch name
# Arguments: $1 - branch name (exact or partial match)
# Returns: Worktree path if found, empty string if not
# First tries exact match, then falls back to case-insensitive fuzzy match
find_worktree_by_branch() {
  local branch_name="$1"
  local match
  match=$(git worktree list --porcelain | grep " $branch_name$" | awk '{print $1}' | head -1)

  if [ -z "$match" ]; then
    # Try fuzzy matching if exact match fails
    match=$(git worktree list | grep -i "$branch_name" | awk '{print $1}' | head -1)
  fi

  echo "$match"
}

# get_current_worktree - Get the path of the current worktree
# Returns: Absolute path to the current worktree's root directory
get_current_worktree() {
  git rev-parse --show-toplevel
}

# ============================================================================
# Command: list
# ============================================================================

# cmd_list - Display all worktrees with their branches
# Shows current worktree with a green checkmark, others with yellow bullet
# Usage: wt list
cmd_list() {
  check_git_repo

  local current_worktree
  current_worktree=$(get_current_worktree)

  echo -e "\n${BLUE}Current worktrees:${NC}"

  # Parse porcelain output: it has 3 lines per worktree (worktree, HEAD, branch)
  local worktree_path=""
  local branch=""

  git worktree list --porcelain | while read -r line; do
    if [[ "$line" =~ ^worktree ]]; then
      # New worktree entry - use parameter expansion instead of sed
      worktree_path="${line#worktree }"
      branch=""
    elif [[ "$line" =~ ^branch ]]; then
      # Extract branch name from refs/heads/branch-name
      branch="${line#branch refs/heads/}"

      # Now display the worktree
      local worktree_name
      worktree_name=$(basename "$worktree_path")

      if [ "$worktree_path" = "$current_worktree" ]; then
        printf "  ${GREEN}✓${NC} %-30s ${BLUE}[${branch}]${NC}\n" "$worktree_name"
      else
        printf "  ${YELLOW}•${NC} %-30s ${BLUE}[${branch}]${NC}\n" "$worktree_name"
      fi
    fi
  done

  echo ""
}

# ============================================================================
# Command: create
# ============================================================================

# cmd_create - Create a new worktree with a branch
# Arguments: $1 - branch name (required)
#            $2 - optional flag: --code (open in editor) or --go (cd + editor)
# Creates worktree in sibling directory using WORKTREE_NAME_PATTERN
# Automatically installs dependencies if AUTO_INSTALL=true
# Usage: wt create <branch-name> [--code|--go]
cmd_create() {
  check_git_repo

  local branch_name="$1"
  local open_code=false
  local go_flag=false

  # Check for flags
  if [ "${2:-}" = "--code" ]; then
    open_code=true
  elif [ "${2:-}" = "--go" ]; then
    go_flag=true
  fi

  if [ -z "$branch_name" ]; then
    error "Branch name required. Usage: wt create <branch-name> [--code|--go]"
  fi

  # Validate branch name before proceeding
  validate_branch_name "$branch_name"

  local repo_root repo_name worktree_name default_branch
  repo_root=$(get_repo_root)
  repo_name=$(get_repo_name)

  # Apply the worktree naming pattern from config
  worktree_name=$(apply_worktree_pattern "$WORKTREE_NAME_PATTERN" "$repo_name" "$branch_name")
  local worktree_path="../${worktree_name}"
  local worktree_full_path="${repo_root}/../${worktree_name}"

  default_branch=$(get_default_branch)
  # Use configured package manager or auto-detect
  local pkg_manager="${PACKAGE_MANAGER}"
  if [ -z "$pkg_manager" ]; then
    pkg_manager=$(get_package_manager)
  fi

  # Check if worktree already exists
  if [ -d "$worktree_full_path" ]; then
    error "Worktree already exists at $worktree_path"
  fi

  # Check if branch already exists
  if git rev-parse --verify "$branch_name" > /dev/null 2>&1; then
    warn "Branch '$branch_name' already exists locally"
    read -p "Continue with existing branch? (y/n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      error "Cancelled"
    fi
    # Create worktree from existing branch
    info "Creating worktree for existing branch..."
    git worktree add "$worktree_full_path" "$branch_name" || error "Failed to create worktree"
  else
    # Create new branch
    info "Creating worktree with new branch..."
    git worktree add -b "$branch_name" "$worktree_full_path" "origin/$default_branch" || error "Failed to create worktree"
  fi

  success "Worktree created at $worktree_path"

  # Install dependencies if AUTO_INSTALL is enabled
  if [ "$AUTO_INSTALL" = "true" ]; then
    info "Installing dependencies in $worktree_path..."
    # Track whether installation succeeds
    local install_success=true
    (
      cd "$worktree_full_path"
      case "$pkg_manager" in
        bun)  bun install  || exit 1 ;;
        npm)  npm install  || exit 1 ;;
        yarn) yarn install || exit 1 ;;
        pnpm) pnpm install || exit 1 ;;
      esac
    ) || install_success=false

    # Report accurately based on actual result
    if [ "$install_success" = true ]; then
      success "Dependencies installed"
    else
      warn "Dependency installation failed - you may need to run install manually"
    fi
  else
    info "Skipping dependency installation (AUTO_INSTALL=false)"
  fi

  # Open editor if requested (via --code or --go flags)
  if [ "$open_code" = true ]; then
    info "Opening editor: $EDITOR"
    # shellcheck disable=SC2086
    $EDITOR $EDITOR_FLAGS "$worktree_full_path" &
  fi

  # Handle --go flag: switch to worktree and launch editor
  if [ "$go_flag" = true ]; then
    info "Switching to worktree and launching editor: $EDITOR"
    cd "$worktree_full_path"
    # shellcheck disable=SC2086
    $EDITOR $EDITOR_FLAGS . &
    success "Opened in: $worktree_full_path"
    echo ""
    return 0
  fi

  info "To switch to this worktree, run: ${BLUE}wt switch $branch_name${NC}"
  echo ""
}

# ============================================================================
# Command: switch
# ============================================================================

# cmd_switch - Switch to an existing worktree by branch name
# Arguments: $1 - branch name (exact or fuzzy match)
# Outputs a cd command for the shell wrapper to eval
# Usage: wt switch <branch-name>
cmd_switch() {
  check_git_repo

  local branch_name="$1"

  if [ -z "$branch_name" ]; then
    error "Branch name required. Usage: wt switch <branch-name>"
  fi

  local worktree_path
  worktree_path=$(find_worktree_by_branch "$branch_name")

  if [ -z "$worktree_path" ]; then
    error "Worktree not found for branch matching '$branch_name'"
  fi

  # Output cd command for shell function to eval
  echo "cd '$worktree_path'"
}

# ============================================================================
# Command: delete
# ============================================================================

# cmd_delete - Remove a worktree and optionally its branch
# Arguments: $1 - branch name (required)
#            $2 - optional flag: --keep-branch (preserve git branch)
# Handles uncommitted changes with interactive prompts
# Deletes both local and remote branches by default
# Usage: wt delete <branch-name> [--keep-branch]
cmd_delete() {
  check_git_repo

  local branch_name="$1"
  local keep_branch=false

  # Check for --keep-branch flag
  if [ "${2:-}" = "--keep-branch" ]; then
    keep_branch=true
  fi

  if [ -z "$branch_name" ]; then
    error "Branch name required. Usage: wt delete <branch-name> [--keep-branch]"
  fi

  local worktree_path current_worktree
  worktree_path=$(find_worktree_by_branch "$branch_name")

  if [ -z "$worktree_path" ]; then
    error "Worktree not found for branch matching '$branch_name'"
  fi

  current_worktree=$(get_current_worktree)

  # If trying to delete current worktree, switch to main first
  if [ "$worktree_path" = "$current_worktree" ]; then
    warn "Cannot delete current worktree. Switching to main repository..."
    local repo_root
    repo_root=$(get_repo_root)
    cd "$repo_root"
    info "Switched to main repository. Now deleting worktree..."
  fi

  # Check for uncommitted changes
  if [ -d "$worktree_path/.git" ]; then
    local has_changes
    has_changes=$(cd "$worktree_path" && git status --porcelain | wc -l)
    if [ "$has_changes" -gt 0 ]; then
      warn "Worktree has uncommitted changes"
      echo "Options:"
      echo "  (c) Commit the changes"
      echo "  (s) Stash the changes"
      echo "  (f) Force delete (will lose changes)"
      echo "  (q) Cancel"
      read -p "What would you like to do? [c/s/f/q] " -n 1 -r
      echo

      case $REPLY in
        c)
          (cd "$worktree_path" && git add -A && git commit -m "WIP: work in progress before deleting worktree")
          ;;
        s)
          (cd "$worktree_path" && git stash)
          ;;
        f)
          warn "Force deleting with uncommitted changes"
          ;;
        *)
          error "Cancelled"
          ;;
      esac
    fi
  fi

  # Remove worktree
  git worktree remove "$worktree_path" || error "Failed to remove worktree"
  success "Worktree deleted at $worktree_path"

  # Delete branch by default (unless --keep-branch)
  if [ "$keep_branch" = false ]; then
    local should_delete_branch=false

    if [ "$DELETE_BRANCH_PROMPT" = "true" ]; then
      # Prompt the user
      read -p "Delete branch '$branch_name' as well? (y/n) " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]]; then
        should_delete_branch=true
      fi
    else
      # Delete without prompting
      should_delete_branch=true
    fi

    if [ "$should_delete_branch" = true ]; then
      # Track what actually gets deleted
      local local_deleted=false
      local remote_deleted=false

      if git branch -D "$branch_name" 2>/dev/null; then
        local_deleted=true
      fi

      if git push origin --delete "$branch_name" 2>/dev/null; then
        remote_deleted=true
      fi

      # Report accurately based on what succeeded
      if [ "$local_deleted" = true ] && [ "$remote_deleted" = true ]; then
        success "Branch deleted (local and remote)"
      elif [ "$local_deleted" = true ]; then
        success "Local branch deleted"
        info "Remote branch not found or already deleted"
      elif [ "$remote_deleted" = true ]; then
        success "Remote branch deleted"
        info "Local branch not found or already deleted"
      else
        info "Branch not found locally or remotely (may already be deleted)"
      fi
    fi
  fi

  # Clean up stale worktree references
  git worktree prune

  echo ""
}

# ============================================================================
# Command: help
# ============================================================================

cmd_help() {
  echo "wt - Simplified Git Worktree Management (v${VERSION})"
  cat << 'EOF'

USAGE:
  wt <command> [options]

COMMANDS:
  list                    List all active worktrees
  create <branch>         Create a new worktree with <branch>
                         Options: --code (opens in configured editor)
                                  --go (cd into worktree + launch editor)
  switch <branch>         Switch to a worktree (via shell function)
  delete <branch>         Delete a worktree (deletes branch by default)
                         Options: --keep-branch (preserve the git branch)
  config <subcommand>     Manage configuration
                         Subcommands: edit, show, reset, path
  help                    Show this help message

CONFIGURATION:
  Config file: ~/.config/wt/config
  Create automatically on first use.

  Available options:
    EDITOR               - Editor command (default: code)
    EDITOR_FLAGS         - Flags for editor (default: "")
    AUTO_INSTALL         - Auto-install dependencies (default: true)
    DELETE_BRANCH_PROMPT - Prompt before deleting branch (default: true)
    PACKAGE_MANAGER      - Override PM detection: bun|npm|yarn|pnpm (default: auto)
    WORKTREE_NAME_PATTERN - Pattern for worktree names (default: {repo}-{branch})

EXAMPLES:
  wt list
  wt create DEV-123
  wt create DEV-123 --code
  wt create DEV-123 --go
  wt switch DEV-123
  wt delete DEV-123
  wt delete DEV-123 --keep-branch

  wt config show            - Display current configuration
  wt config edit            - Edit config in editor
  wt config path            - Show config file location
  wt config reset           - Reset to defaults

SHELL SETUP (required for 'switch' to work):
  Add this function to your ~/.zshrc:

    wt() {
      local script="$HOME/.claude/skills/git-worktree-guide/wt"
      if [ "$1" = "switch" ] || ([ $# -eq 1 ] && [ "$1" != "list" ] && [ "$1" != "create" ] && [ "$1" != "delete" ] && [ "$1" != "config" ] && [ "$1" != "help" ]); then
        local output=$("$script" "$@")
        if [ $? -eq 0 ]; then
          eval "$output"
        else
          echo "$output"
        fi
      else
        "$script" "$@"
      fi
    }

EOF
}

# ============================================================================
# Command: config
# ============================================================================

cmd_config() {
  local subcommand="${1:-show}"

  case "$subcommand" in
    edit)
      # Open config file in editor
      if [ ! -f "$CONFIG_FILE" ]; then
        init_config
      fi

      if [ -z "$EDITOR" ] || [ "$EDITOR" = "code" ]; then
        code "$CONFIG_FILE"
      else
        "$EDITOR" "$CONFIG_FILE"
      fi
      success "Config file opened in editor"
      ;;
    show)
      # Display current configuration
      if [ ! -f "$CONFIG_FILE" ]; then
        info "No config file found. Using defaults."
        echo ""
      else
        echo -e "${BLUE}Current configuration (from $CONFIG_FILE):${NC}"
        cat "$CONFIG_FILE"
        echo ""
      fi

      echo -e "${BLUE}Active settings:${NC}"
      echo "  EDITOR: $EDITOR"
      echo "  EDITOR_FLAGS: ${EDITOR_FLAGS:-(none)}"
      echo "  AUTO_INSTALL: $AUTO_INSTALL"
      echo "  DELETE_BRANCH_PROMPT: $DELETE_BRANCH_PROMPT"
      echo "  PACKAGE_MANAGER: ${PACKAGE_MANAGER:-(auto-detect)}"
      echo "  WORKTREE_NAME_PATTERN: $WORKTREE_NAME_PATTERN"
      echo ""
      ;;
    reset)
      # Reset to defaults by removing config file
      if [ -f "$CONFIG_FILE" ]; then
        read -p "Reset configuration to defaults? This will delete $CONFIG_FILE (y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
          rm "$CONFIG_FILE"
          success "Configuration reset to defaults"
        else
          info "Reset cancelled"
        fi
      else
        info "Already using default configuration"
      fi
      echo ""
      ;;
    path)
      # Show the config file path
      echo "$CONFIG_FILE"
      ;;
    *)
      error "Unknown config subcommand: $subcommand. Use: edit, show, reset, path"
      ;;
  esac
}

# ============================================================================
# Main
# ============================================================================

main() {
  # Initialize config directory if needed (silent - only creates on first run)
  if [ ! -d "$CONFIG_DIR" ]; then
    mkdir -p "$CONFIG_DIR"
  fi

  # Load user configuration (must happen before any command)
  load_config

  local command="${1:-help}"

  case "$command" in
    list)
      cmd_list
      ;;
    create)
      cmd_create "${2:-}" "${3:-}"
      ;;
    switch)
      cmd_switch "${2:-}"
      ;;
    delete)
      cmd_delete "${2:-}" "${3:-}"
      ;;
    --version|-v|version)
      echo "wt version ${VERSION}"
      exit 0
      ;;
    config)
      cmd_config "${2:-show}"
      ;;
    help|--help|-h)
      cmd_help
      ;;
    *)
      error "Unknown command: $command. Run 'wt help' for usage."
      ;;
  esac
}

# Run main with all arguments
main "$@"
